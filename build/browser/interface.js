var i=class{static arrayFy(t){return Array.isArray(t)||(t=Array(t)),t}},y=["prototype","constructor",...Reflect.ownKeys(Function.prototype),...Reflect.ownKeys(Function.constructor)].filter((n,t,e)=>e.indexOf(n)===t),o=class{static getFnPrototype(t){return t.prototype?t:Reflect.getPrototypeOf(t)}static getMethods(t){return Reflect.ownKeys(o.getFnPrototype(t)).filter(e=>t[e]instanceof Function)}static isNotDefaultMethod(t){return!y.includes(t)}static assignFnMethodFromFn(t,e,r){Object.defineProperty(t,r,Object.getOwnPropertyDescriptor(e,r))}static extendsFnMethodsByFn(t,e){return o.getMethods(e).filter(o.isNotDefaultMethod).map(r=>o.assignFnMethodFromFn(t,e,r))}static assignFlatMethods(t,e){return e.reduce((r,s)=>(o.extendsFnMethodsByFn(r,s),r),t)}static extendInterfaces(t){return o.assignFlatMethods(class{},i.arrayFy(t))}};var a=function(n,t){return new Proxy(n,t)},u=class extends a{constructor(t,e){let r=o.extendInterfaces(e);super(t,{get(s,c){if(r[c]instanceof Function)return r[c](s[c])}})}};export{u as Interface};
//# sourceMappingURL=interface.js.map
