var u=class{static arrayFy(t){return Array.isArray(t)?t:t=Array(t)}},a=["prototype","constructor",...Reflect.ownKeys(Function.prototype),...Reflect.ownKeys(Function.constructor)].filter((o,t,e)=>e.indexOf(o)===t),n=class{static getFnPrototype(t){return t.prototype?t:Reflect.getPrototypeOf(t)}static getMethods(t){return Reflect.ownKeys(n.getFnPrototype(t)).filter(e=>t[e]instanceof Function)}static isNotDefaultMethod(t){return!a.includes(t)}static assignFnMethodFromFn(t,e,r){return t[r]=e[r]}static extendsFnMethodsByFn(t,e){return n.getMethods(e).filter(n.isNotDefaultMethod).map(r=>n.assignFnMethodFromFn(t,e,r))}static assignFlatMethods(t,e){return e.reduce((r,s)=>(n.extendsFnMethodsByFn(r,s),r),t)}static extendInterfaces(t){return n.assignFlatMethods(class{},u.arrayFy(t))}};var d=function(o,t){return new Proxy(o,t)},i=class extends d{constructor(t,e){let r=n.extendInterfaces(e);super(t,{get(s,c){if(r[c]instanceof Function)return r[c](s[c])}})}};export{i as Interface};
//# sourceMappingURL=interface.js.map
